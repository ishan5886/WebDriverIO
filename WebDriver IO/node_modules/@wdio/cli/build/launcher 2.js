"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const async_exit_hook_1 = __importDefault(require("async-exit-hook"));
const logger_1 = __importDefault(require("@wdio/logger"));
const config_1 = require("@wdio/config");
const utils_1 = require("@wdio/utils");
const interface_1 = __importDefault(require("./interface"));
const utils_2 = require("./utils");
const log = logger_1.default('@wdio/cli:launcher');
class Launcher {
    constructor(_configFilePath, _args = {}, _isWatchMode = false) {
        var _a, _b;
        this._configFilePath = _configFilePath;
        this._args = _args;
        this._isWatchMode = _isWatchMode;
        this._exitCode = 0;
        this._hasTriggeredExitRoutine = false;
        this._schedule = [];
        this._rid = [];
        this._runnerStarted = 0;
        this._runnerFailed = 0;
        this.configParser = new config_1.ConfigParser();
        /**
         * autocompile before parsing configs so we support ES6 features in configs, only if
         */
        if (
        /**
         * the auto compile option is not define in this case we automatically compile
         */
        typeof ((_a = _args.autoCompileOpts) === null || _a === void 0 ? void 0 : _a.autoCompile) === 'undefined' ||
            /**
             * or it was define and its value is not false
             */
            ((_b = _args.autoCompileOpts) === null || _b === void 0 ? void 0 : _b.autoCompile) !== 'false') {
            this.configParser.autoCompile();
        }
        this.configParser.addConfigFile(_configFilePath);
        this.configParser.merge(_args);
        const config = this.configParser.getConfig();
        /**
         * assign parsed autocompile options into args so it can be used within the worker
         * without having to read the config again
         */
        this._args.autoCompileOpts = config.autoCompileOpts;
        const capabilities = this.configParser.getCapabilities();
        this.isMultiremote = !Array.isArray(capabilities);
        if (config.outputDir) {
            fs_extra_1.default.ensureDirSync(path_1.default.join(config.outputDir));
            process.env.WDIO_LOG_PATH = path_1.default.join(config.outputDir, 'wdio.log');
        }
        logger_1.default.setLogLevelsConfig(config.logLevels, config.logLevel);
        const totalWorkerCnt = Array.isArray(capabilities)
            ? capabilities
                .map((c) => this.configParser.getSpecs(c.specs, c.exclude).length)
                .reduce((a, b) => a + b, 0)
            : 1;
        const Runner = utils_1.initialisePlugin(config.runner, 'runner').default;
        this.runner = new Runner(_configFilePath, config);
        this.interface = new interface_1.default(config, totalWorkerCnt, this._isWatchMode);
        config.runnerEnv.FORCE_COLOR = Number(this.interface.hasAnsiSupport);
    }
    /**
     * run sequence
     * @return  {Promise}               that only gets resolves with either an exitCode or an error
     */
    async run() {
        /**
         * catches ctrl+c event
         */
        async_exit_hook_1.default(this.exitHandler.bind(this));
        let exitCode = 0;
        let error = undefined;
        try {
            const config = this.configParser.getConfig();
            const caps = this.configParser.getCapabilities();
            const { ignoredWorkerServices, launcherServices } = utils_1.initialiseLauncherService(config, caps);
            this._launcher = launcherServices;
            this._args.ignoredWorkerServices = ignoredWorkerServices;
            /**
             * run pre test tasks for runner plugins
             * (e.g. deploy Lambda function to AWS)
             */
            await this.runner.initialise();
            /**
             * run onPrepare hook
             */
            log.info('Run onPrepare hook');
            await utils_2.runLauncherHook(config.onPrepare, config, caps);
            await utils_2.runServiceHook(this._launcher, 'onPrepare', config, caps);
            exitCode = await this.runMode(config, caps);
            /**
             * run onComplete hook
             * even if it fails we still want to see result and end logger stream
             */
            log.info('Run onComplete hook');
            await utils_2.runServiceHook(this._launcher, 'onComplete', exitCode, config, caps);
            const onCompleteResults = await utils_2.runOnCompleteHook(config.onComplete, config, caps, exitCode, this.interface.result);
            // if any of the onComplete hooks failed, update the exit code
            exitCode = onCompleteResults.includes(1) ? 1 : exitCode;
            await logger_1.default.waitForBuffer();
            this.interface.finalise();
        }
        catch (err) {
            error = err;
        }
        finally {
            if (!this._hasTriggeredExitRoutine) {
                this._hasTriggeredExitRoutine = true;
                await this.runner.shutdown();
            }
        }
        if (error) {
            throw error;
        }
        return exitCode;
    }
    /**
     * run without triggering onPrepare/onComplete hooks
     */
    runMode(config, caps) {
        /**
         * fail if no caps were found
         */
        if (!caps) {
            return new Promise((resolve) => {
                log.error('Missing capabilities, exiting with failure');
                return resolve(1);
            });
        }
        /**
         * avoid retries in watch mode
         */
        const specFileRetries = this._isWatchMode ? 0 : config.specFileRetries;
        /**
         * schedule test runs
         */
        let cid = 0;
        if (this.isMultiremote) {
            /**
             * Multiremote mode
             */
            this._schedule.push({
                cid: cid++,
                caps: caps,
                specs: this.formatSpecs(caps, specFileRetries),
                availableInstances: config.maxInstances || 1,
                runningInstances: 0
            });
        }
        else {
            /**
             * Regular mode
             */
            for (let capabilities of caps) {
                this._schedule.push({
                    cid: cid++,
                    caps: capabilities,
                    specs: this.formatSpecs(capabilities, specFileRetries),
                    availableInstances: capabilities.maxInstances || config.maxInstancesPerCapability,
                    runningInstances: 0
                });
            }
        }
        return new Promise((resolve) => {
            this._resolve = resolve;
            /**
             * fail if no specs were found or specified
             */
            if (Object.values(this._schedule).reduce((specCnt, schedule) => specCnt + schedule.specs.length, 0) === 0) {
                log.error('No specs found to run, exiting with failure');
                return resolve(1);
            }
            /**
             * return immediately if no spec was run
             */
            if (this.runSpecs()) {
                resolve(0);
            }
        });
    }
    /**
     * Format the specs into an array of objects with files and retries
     */
    formatSpecs(capabilities, specFileRetries) {
        let files = [];
        files = this.configParser.getSpecs(capabilities.specs, capabilities.exclude);
        return files.map(file => {
            if (typeof file === 'string') {
                return { files: [file], retries: specFileRetries };
            }
            else if (Array.isArray(file)) {
                return { files: file, retries: specFileRetries };
            }
            log.warn('Unexpected entry in specs that is neither string nor array: ', file);
            // Returning an empty structure to avoid undefined
            return { files: [], retries: specFileRetries };
        });
    }
    /**
     * run multiple single remote tests
     * @return {Boolean} true if all specs have been run and all instances have finished
     */
    runSpecs() {
        let config = this.configParser.getConfig();
        /**
         * stop spawning new processes when CTRL+C was triggered
         */
        if (this._hasTriggeredExitRoutine) {
            return true;
        }
        while (this.getNumberOfRunningInstances() < config.maxInstances) {
            let schedulableCaps = this._schedule
                /**
                 * bail if number of errors exceeds allowed
                 */
                .filter(() => {
                const filter = typeof config.bail !== 'number' || config.bail < 1 ||
                    config.bail > this._runnerFailed;
                /**
                 * clear number of specs when filter is false
                 */
                if (!filter) {
                    this._schedule.forEach((t) => { t.specs = []; });
                }
                return filter;
            })
                /**
                 * make sure complete number of running instances is not higher than general maxInstances number
                 */
                .filter(() => this.getNumberOfRunningInstances() < config.maxInstances)
                /**
                 * make sure the capability has available capacities
                 */
                .filter((a) => a.availableInstances > 0)
                /**
                 * make sure capability has still caps to run
                 */
                .filter((a) => a.specs.length > 0)
                /**
                 * make sure we are running caps with less running instances first
                 */
                .sort((a, b) => a.runningInstances - b.runningInstances);
            /**
             * continue if no capability were schedulable
             */
            if (schedulableCaps.length === 0) {
                break;
            }
            let specs = schedulableCaps[0].specs.shift();
            this.startInstance(specs.files, schedulableCaps[0].caps, schedulableCaps[0].cid, specs.rid, specs.retries);
            schedulableCaps[0].availableInstances--;
            schedulableCaps[0].runningInstances++;
        }
        return this.getNumberOfRunningInstances() === 0 && this.getNumberOfSpecsLeft() === 0;
    }
    /**
     * gets number of all running instances
     * @return {number} number of running instances
     */
    getNumberOfRunningInstances() {
        return this._schedule.map((a) => a.runningInstances).reduce((a, b) => a + b);
    }
    /**
     * get number of total specs left to complete whole suites
     * @return {number} specs left to complete suite
     */
    getNumberOfSpecsLeft() {
        return this._schedule.map((a) => a.specs.length).reduce((a, b) => a + b);
    }
    /**
     * Start instance in a child process.
     * @param  {Array} specs  Specs to run
     * @param  {Number} cid  Capabilities ID
     * @param  {String} rid  Runner ID override
     * @param  {Number} retries  Number of retries remaining
     */
    async startInstance(specs, caps, cid, rid, retries) {
        let config = this.configParser.getConfig();
        // wait before retrying the spec file
        if (typeof config.specFileRetriesDelay === 'number' && config.specFileRetries > 0 && config.specFileRetries !== retries) {
            await utils_1.sleep(config.specFileRetriesDelay * 1000);
        }
        // Retried tests receive the cid of the failing test as rid
        // so they can run with the same cid of the failing test.
        const runnerId = rid || this.getRunnerId(cid);
        let processNumber = this._runnerStarted + 1;
        // process.debugPort defaults to 5858 and is set even when process
        // is not being debugged.
        let debugArgs = [];
        let debugType;
        let debugHost = '';
        let debugPort = process.debugPort;
        for (let i in process.execArgv) {
            const debugArgs = process.execArgv[i].match('--(debug|inspect)(?:-brk)?(?:=(.*):)?');
            if (debugArgs) {
                let [, type, host] = debugArgs;
                if (type) {
                    debugType = type;
                }
                if (host) {
                    debugHost = `${host}:`;
                }
            }
        }
        if (debugType) {
            debugArgs.push(`--${debugType}=${debugHost}${(debugPort + processNumber)}`);
        }
        // if you would like to add --debug-brk, use a different port, etc...
        let capExecArgs = [...(config.execArgv || [])];
        // The default value for child.fork execArgs is process.execArgs,
        // so continue to use this unless another value is specified in config.
        let defaultArgs = (capExecArgs.length) ? process.execArgv : [];
        // If an arg appears multiple times the last occurrence is used
        let execArgv = [...defaultArgs, ...debugArgs, ...capExecArgs];
        // bump up worker count
        this._runnerStarted++;
        // run worker hook to allow modify runtime and capabilities of a specific worker
        log.info('Run onWorkerStart hook');
        await utils_2.runLauncherHook(config.onWorkerStart, runnerId, caps, specs, this._args, execArgv);
        await utils_2.runServiceHook(this._launcher, 'onWorkerStart', runnerId, caps, specs, this._args, execArgv);
        // prefer launcher settings in capabilities over general launcher
        const worker = this.runner.run({
            cid: runnerId,
            command: 'run',
            configFile: this._configFilePath,
            args: { ...this._args, ...((config === null || config === void 0 ? void 0 : config.autoCompileOpts) ? { autoCompileOpts: config.autoCompileOpts } : {}) },
            caps,
            specs,
            execArgv,
            retries
        });
        worker.on('message', this.interface.onMessage.bind(this.interface));
        worker.on('error', this.interface.onMessage.bind(this.interface));
        worker.on('exit', this.endHandler.bind(this));
    }
    /**
     * generates a runner id
     * @param  {Number} cid capability id (unique identifier for a capability)
     * @return {String}     runner id (combination of cid and test id e.g. 0a, 0b, 1a, 1b ...)
     */
    getRunnerId(cid) {
        if (!this._rid[cid]) {
            this._rid[cid] = 0;
        }
        return `${cid}-${this._rid[cid]++}`;
    }
    /**
     * Close test runner process once all child processes have exited
     * @param  {Number} cid       Capabilities ID
     * @param  {Number} exitCode  exit code of child process
     * @param  {Array} specs      Specs that were run
     * @param  {Number} retries   Number or retries remaining
     */
    endHandler({ cid: rid, exitCode, specs, retries }) {
        const passed = this._isWatchModeHalted() || exitCode === 0;
        if (!passed && retries > 0) {
            // Default is true, so test for false explicitly
            const requeue = this.configParser.getConfig().specFileRetriesDeferred !== false ? 'push' : 'unshift';
            this._schedule[parseInt(rid, 10)].specs[requeue]({ files: specs, retries: retries - 1, rid });
        }
        else {
            this._exitCode = this._isWatchModeHalted() ? 0 : this._exitCode || exitCode;
            this._runnerFailed += !passed ? 1 : 0;
        }
        /**
         * avoid emitting job:end if watch mode has been stopped by user
         */
        if (!this._isWatchModeHalted()) {
            this.interface.emit('job:end', { cid: rid, passed, retries });
        }
        /**
         * Update schedule now this process has ended
         */
        // get cid (capability id) from rid (runner id)
        const cid = parseInt(rid, 10);
        this._schedule[cid].availableInstances++;
        this._schedule[cid].runningInstances--;
        /**
         * do nothing if
         * - there are specs to be executed
         * - we are running watch mode
         */
        const shouldRunSpecs = this.runSpecs();
        if (!shouldRunSpecs || (this._isWatchMode && !this._hasTriggeredExitRoutine)) {
            return;
        }
        if (this._resolve) {
            this._resolve(passed ? this._exitCode : 1);
        }
    }
    /**
     * We need exitHandler to catch SIGINT / SIGTERM events.
     * Make sure all started selenium sessions get closed properly and prevent
     * having dead driver processes. To do so let the runner end its Selenium
     * session first before killing
     */
    exitHandler(callback) {
        if (!callback) {
            return;
        }
        if (this._hasTriggeredExitRoutine) {
            return callback();
        }
        this._hasTriggeredExitRoutine = true;
        this.interface.sigintTrigger();
        return this.runner.shutdown().then(callback);
    }
    /**
     * returns true if user stopped watch mode, ex with ctrl+c
     * @returns {boolean}
     */
    _isWatchModeHalted() {
        return this._isWatchMode && this._hasTriggeredExitRoutine;
    }
}
exports.default = Launcher;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbGF1bmNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxnREFBdUI7QUFDdkIsd0RBQXlCO0FBQ3pCLHNFQUFzQztBQUV0QywwREFBaUM7QUFDakMseUNBQTJDO0FBQzNDLHVDQUFnRjtBQUdoRiw0REFBcUM7QUFFckMsbUNBQTRFO0FBRTVFLE1BQU0sR0FBRyxHQUFHLGdCQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQTtBQXVCeEMsTUFBTSxRQUFRO0lBZ0JWLFlBQ1ksZUFBdUIsRUFDdkIsUUFBc0MsRUFBRSxFQUN4QyxlQUFlLEtBQUs7O1FBRnBCLG9CQUFlLEdBQWYsZUFBZSxDQUFRO1FBQ3ZCLFVBQUssR0FBTCxLQUFLLENBQW1DO1FBQ3hDLGlCQUFZLEdBQVosWUFBWSxDQUFRO1FBYnhCLGNBQVMsR0FBRyxDQUFDLENBQUE7UUFDYiw2QkFBd0IsR0FBRyxLQUFLLENBQUE7UUFDaEMsY0FBUyxHQUFlLEVBQUUsQ0FBQTtRQUMxQixTQUFJLEdBQWEsRUFBRSxDQUFBO1FBQ25CLG1CQUFjLEdBQUcsQ0FBQyxDQUFBO1FBQ2xCLGtCQUFhLEdBQUcsQ0FBQyxDQUFBO1FBVXJCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxxQkFBWSxFQUFFLENBQUE7UUFFdEM7O1dBRUc7UUFDSDtRQUNJOztXQUVHO1FBQ0gsY0FBTyxLQUFLLENBQUMsZUFBZSwwQ0FBRSxXQUFXLENBQUEsS0FBSyxXQUFXO1lBQ3pEOztlQUVHO1lBQ0gsQ0FBQyxNQUFBLEtBQUssQ0FBQyxlQUFlLDBDQUFFLFdBQTZCLE1BQUssT0FBTyxFQUNuRTtZQUNFLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUE7U0FDbEM7UUFFRCxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQTtRQUNoRCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxL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